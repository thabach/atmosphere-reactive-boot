package com.yulplay.reactive.boot;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.yulplay.protocol.Enveloppe;
import org.atmosphere.cpr.AtmosphereRequest;
import org.atmosphere.cpr.AtmosphereResponse;
import org.atmosphere.websocket.WebSocket;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Attach this object to a WebSocket so any {@link Service} can retrieve this
 * object and invoke a Reply.
 *
 * It gives better performance when the a unique Reply is defined. See the {@link ReactivesWebSocketProcessor#open(WebSocket, AtmosphereRequest, AtmosphereResponse)}
 * for an example of a bytes typed reply for an example. If new Service needs different reply, then property 'yulplay.kafka.websocket.uniqueReply'
 * should be set to false, hence one reply per message will be used.
 */
public class MessageReceiver {
    private final Logger logger = LoggerFactory.getLogger(MessageReceiver.class);

    private final ObjectMapper mapper;
    private final Map<String, Reply> idWithReply = new ConcurrentHashMap<>();
    private final Reply<byte[]> uniqueReply;

    public MessageReceiver(ObjectMapper mapper) {
        this.mapper = mapper;
        this.uniqueReply = null;
    }

    public MessageReceiver(ObjectMapper mapper, final WebSocket webSocket) {
        this.mapper = mapper;
        this.uniqueReply = new Reply<byte[]>() {
            @Override
            public void ok(byte[] bytes) {
                try {
                    webSocket.write(bytes, 0, bytes.length);
                } catch (IOException e) {
                    logger.warn("", e);
                }
            }

            @Override
            public void fail(ReplyException replyException) {
                MessageReceiver.this.discard(replyException.message().uuid());
            }
        };
    }

    public MessageReceiver apply(Enveloppe enveloppe) throws JsonProcessingException {
        Reply reply = uniqueReply != null ? uniqueReply : idWithReply.remove(enveloppe.uuid());
        if (reply != null) {
            reply.ok(mapper.writeValueAsBytes(enveloppe));
        } else {
            /**
             * This issue may arise when a WebSocket#uuid() return the same value as another Tubes
             * (since the UUID are not unique amongst Tubes as they are generated by Netty.
             *
             * This is not a bug because the real WebSocket will be retrieved by another Tubes
             *
             * The only risk here is the Message#uuid is not using as wel, so there is a small windows
             * both WebSocket#uuid() and Message#uuid() matches and the message is sent to the wrong client.
             *
             * TODO: An outside UUID service or server could find this issue.
             */
            logger.warn("No MessageReceiver for {}. Registered message are {}", enveloppe.uuid(), idWithReply);
        }
        return this;
    }

    public MessageReceiver apply(String uuid, byte[] message) throws JsonProcessingException {
        Reply reply = uniqueReply != null ? uniqueReply : idWithReply.remove(uuid);
        if (reply != null) {
            reply.ok(message);
        } else {
            logger.error("No receiver for {}", message);
        }
        return this;
    }

    public MessageReceiver receiveWith(Enveloppe t, Reply r) {
        idWithReply.put(t.uuid(), r);
        return this;
    }

    public void destroy() {
        idWithReply.clear();
        /* idWithReply = null; */
    }

    public Reply<byte[]> receiveWith(){
        return uniqueReply;
    }

    public MessageReceiver discard(String uuid) {
        idWithReply.remove(uuid);
        return this;
    }
}
